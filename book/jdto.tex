
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage[colorlinks=true,linkcolor=black]{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots.
\geometry{a4paper} % or letter or a5paper or ... etc
% \geometry{landscape} % rotated page geometry

%\date{} % delete this line to display the current date

%customized commands and environments
\newcommand{\JDTO}{jDTO Binder\xspace}
\newcommand{\JDV}{1.0-RC\xspace}
\newcommand{\DEFAULTCONFIG}{/jdto-mappings.xml\xspace}

%for java syntax highlighting
\lstnewenvironment{java}
{\lstset{
		language=Java, 
		basicstyle=\small\sffamily, 
		frame=line, 
		commentstyle=\sffamily\textit, 
		numbers=left, 
		numberstyle=\ttfamily,
		aboveskip=5mm,
		belowskip=5mm,
		breaklines=true,
		breakautoindent=true,
		showstringspaces=false
	}
}
{}

%for xml syntax highlighting
\lstnewenvironment{xml}
{\lstset{
		language=Xml, 
		basicstyle=\small\sffamily, 
		frame=line, 
		commentstyle=\sffamily\textit, 
		aboveskip=5mm,
		belowskip=5mm,
		breaklines=true,
		breakautoindent=true,
		showstringspaces=false
	}
}
{}

\hypersetup{
			pdfauthor={Juan Alberto López Cavallotti},
			pdftitle= {jDTO Binder User's Guide},
			pdfsubject= {jDTO Binder User's Guide}
			}


% See the ``Article customize'' template for come common customizations

\title{\JDTO \JDV User's Guide}
\author{Juan Alberto López Cavallotti}


%%% BEGIN DOCUMENT
\begin{document}

\maketitle

\begin{center}

\includegraphics[scale=1]{logo.png}

\begin{huge}
 http://www.jdto.org
\end{huge}
\end{center}


\newpage
\tableofcontents

\newpage

%%%%% Begining of real content.

\section{Introduction}


Welcome to \JDTO framework, the main goal of \JDTO is to leverage the repetitive work it takes to use
the DTO pattern for robust software architectures. 

\JDTO transforms manual shallow and deep copy processes into a declarative process. By default, the framework
takes the shallow copy approach, but with mechanisms such as cascading and cloning the user may achieve deep
copying.

Mainly the incorrect use of DTOs have some strong
disadvantages: 

\begin{itemize}
\item Multi powerful DTOs and the lost of lazy loading.
\item High memory footprint (and unnecessary).
\item Hard to maintain service layer API's.
\end{itemize}

The discussion of wether the DTOs are useful or not is left out of the picture. It depends specially on 
the architect and the size of the application. As a personal opinion I like mixed architectures, there are
moments where DTOs are useful and there are moments where DTOs are a heavy load.

\subsection{What's new in \JDV}

\JDTO \JDV introduces new features:
\begin{itemize}
\item New namespace in packaging to match the framework website.
\item New maven artifact namespace to match the framework website.
\item Updated documentation heading towards the final release.
\item Updated the location of the maven repository.
\end{itemize}

Issues solved:
\begin{itemize}
\item With the new maven repository, the server answers with a 404 error when looking for missing resources so maven won't blacklist it.
\end{itemize}

\subsection{Getting the Source}

Currently, \JDTO is hosted as an open source GitHub project and licensed with the Apache 2 open source license. You can find the source code deployed on \JDTO maven repository or in GitHub. The GitHub project url is: 

https://github.com/juancavallotti/jDTO-Binder

You may contribute by submitting a bug or extending the framework in different ways, if you want to contribute please take a look at http://www.jdto.org/\#contribute.

\section{Quick Start}


To start using \JDTO you'll have to add it to your maven dependencies, this can be done
by adding it to your pom.xml under the dependencies section, you also want to add commons-lang and slf4j:

%%%%%%%%%% TODO - MANUAL VERSION CHANGE
\begin{xml}
     <dependencies>
     ...
        <dependency>
            <groupId>org.jdto</groupId>
            <artifactId>jdto</artifactId>
            <version>1.0-RC</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
            <version>1.6.2</version>
        </dependency>
        <dependency>
            <groupId>commons-lang</groupId>
            <artifactId>commons-lang</artifactId>
            <version>2.6</version>
        </dependency>
     ...
     <dependencies>
\end{xml}

You also want to add the \JDTO repository to your pom.xml file:

\begin{xml}
     <repositories>
        <repository>
            <id>org.jdto</id>
            <name>jdto</name>
            <url>http://maven2.jdto.org/</url>
            <layout>default</layout>
        </repository>
    </repositories>
\end{xml}

This's all what's required in terms of dependencies, so now we can start binding DTOs.

\subsection{Bootstrapping the Binder}


In order to bind DTOs, a binder must be bootstrapped. At the moment two types of binders
are supported: the core binder, and the spring framework binder\footnote{In order to use the spring framework binder, you should add the spring framework dependency.}.


The following snippet shows how to bootstrap the core binder, the core binder is kept as a singleton instance, so it's safe to call the \texttt{getBinder()} method at any time, and the same instance will be returned.


\begin{java}
//init the binder as a singleton.
DTOBinder binder = DTOBinderFactory.getBinder();
\end{java}

You may also bootstrap the DTO binder based on an XML configuration file, for this matter you'll have to provide an \texttt{InputStream} instance pointing to the XML configuration file, the following is an example of how you can bootstrap the binder this way:


\begin{java}
DTOBinder binder = DTOBinderFactory.buildBinder(
    DTOBinder.class.getResourceAsStream("/xmlmappingtest.xml"));
\end{java}

By default, the framework looks for a file named \DEFAULTCONFIG on the classpath, if this file is present and no other XML file has been specified, then it will use XML configuration instead of annotations with the configuration specified in \DEFAULTCONFIG file.

The bean analysis over XML file is kind of expensive (not much but kind of) so to get the best performance you should keep that bean as a singleton.

\subsection{Basic DTO Binding}


Once we have our binder instance bootstrapped, we can start binding objects. \JDTO uses the "convention over configuration"
methodology, therefore if you don't add any kind of mapping it will assume default values as a convention. 


In the following example there's one property bound by convention and the other one bound by configuration.


\begin{java}
//bind entities
MixedEntity entity = new MixedEntity();
entity.setSomeString("hello world!");
entity.setSomeInt(15);
        
BasicDTO dto = binder.bindFromBusinessObject(BasicDTO.class, entity);
        
logger.info(dto.toString());
\end{java}

The relevant entity and DTO declarations are:


\begin{java}
 public class MixedEntity {
    private String someString;
    private int someInt;
    private double someDouble;
    private Date someDate;
    
    ... //getters and setters
}

public class BasicDTO {
    private String someString;
    
    @Source("someInt")
    private int personAge;
    
    ... //getters and setters
}
\end{java}

You may want to keep track of the \texttt{MixedEntity} structure for it will be used on the future
to demonstrate features of \JDTO.

The first attribute \texttt{someString} is bound by convention, and the second one is bound
by configuration using the \texttt{@Source} annotation.

If the object passed as entity is an implementation of \texttt{java.util.Map}, then the values will be read as keys of the map instead of calling the object's getters, this means you can populate an object from a map, this also applies if a cascaded property is a map. 

\section{Integration}

\subsection{Integration with the Spring Framework}

\JDTO provides out-of-the-box integration with the spring framework. By default \JDTO uses annotation-based configuration for the binder, here is how to bootstrap it to be used within the spring framework xml configuration file:


\begin{xml}
<!-- THE DTO BINDER BEAN --> 
<bean id="dtobinder" 
    class="org.jdto.spring.SpringDTOBinder" />
\end{xml}


You may want to use an XML configuration file instead of regular annotations. The spring framework integration
provides a way to configure the DTO Binder instance to read the xml configuration file. By default, it will try to look for the \DEFAULTCONFIG file on the class path, this can be changed by implicitly specifying a configuration file:


\begin{xml}
<!-- THE DTO BINDER BEAN --> 
<bean class="org.jdto.spring.SpringDTOBinder">
    <property name="xmlConfig" value="classpath:/dtos.xml" />
</bean>
\end{xml}


Note: The binder instance is of the kind of instances you want to keep as singleton. This is because even though it can analyze a bean on the fly, it caches it's metadata to have a quicker access on the future.

Once configured, you can inject the binder bean as usual, for example:


\begin{java}
@Autowired
private DTOBinder binder;
\end{java}

\subsection{Integration with CDI}

\JDTO library provides a CDI jar and also a way to inject the DTO binder instance into your own beans. Due to some restrictions on the design of CDI, it was a decision to make this integration as a separate library, so you must change your pom dependencies to:

%%%%%%%%%% TODO - MANUAL VERSION CHANGE

\begin{xml}
    <dependency>
        <groupId>org.jdto</groupId>
        <artifactId>jdto-cdi</artifactId>
        <version>1.0-RC</version>
    </dependency>
\end{xml}

In the following example is shown the typical case of injection via CDI:


\begin{java}
@Inject
private DTOBinder binder;
\end{java}

The jdto-cdi dependency has as implicit dependency the jdto framework so you should not have to add it explicitly, nevertheless you may add it if that is your taste.
 

\section{Simple Field Binding}


To bind simple fields you want to use the \texttt{@Source} annotation type.
This annotation type can take four parameters but only three are commented in this section:

\begin{itemize}
 \item value: Indicates the source field to read from, can be a property path.
 \item merger: An implementation of \texttt{SinglePropertyValueMerger} which will take care of the transformation of this item as a single thing.
 \item mergerParam: A string param which may help the merger to decide how to convert the value.
\end{itemize}

Users are encouraged to create their own implementations. \textbf{\underline{Important Note}}: The user should see
the value mergers as singleton, therefore the use of instance variables is discouraged unless you know what you're doing.


\subsection{List of Built-in field Mergers}


The following is a complete list of the built-in single field mergers and a brief explanation:

\begin{itemize}
 \item \texttt{AgeMerger}: Evaluates the age in days, weeks or years of a date or calendar instance.
 \item \texttt{CloneMerger}: Call clone in cloneable objects.
 \item \texttt{DateFormatMerger}: Formats a Date or Calendar instance by applying a format String.
 \item \texttt{DecimalFormatMerger}: Format any number by applying a format String.
 \item \texttt{EnumMerger}: Convert an enum literal to it's String representation.
 \item \texttt{IdentityPropertyValueMerger}: Default merger, returns the same instance of the value.
 \item \texttt{StringFormatMerger}: Format the value by using a format string (String.format).
 \item \texttt{ExpressionMerger}: Evaluate a math expression out out literal values and properties of the input bean (or the actual value if the input does not represent a bean).
 \item \texttt{PropertyCollectionMerger}: Converts a collection of objects into a collection of one property of those objects.
 \item \texttt{SumMerger}: Add all of the items of a collection (or some property of it) into a single double.
 \item \texttt{SumExpressionMerger}: Add all the results of an expression evaluation for each value of a bean collection or array.
 \item \texttt{SumProductMerger}: Add all the results of a multiplication between properties for each value of a bean collection or array, for example an SQL equivalent would be: \texttt{SELECT sum(itemPrice * amount * taxRate) FROM billItems }. This is a convenience implementation which should be picked instead of \texttt{SumExpressionMerger} because is more efficient.
 \item \texttt{ToStringMerger}: Convert any object into it's string representation by calling toString.
\end{itemize}

\underline{Note about expression evaluation}: Currently the expression evaluation API supports only five operators: addition (+), subtraction (-), multiplication (*), division(/), and pow (\symbol{94}). Also it supports negative numbers and any amount of balanced parenthesis. If the expression is not well formed, the framework will throw an \texttt{IllegalArgumentException}.

Here is an example usage of the \texttt{DateFormatMerger}, it will output something like "2011/10/11".


\begin{java}
@Source(value = "someDate", 
    merger=DateFormatMerger.class, mergerParam="yyyy/MM/dd")
private String formattedDate;
\end{java}

\subsection{Transient Values}


There are cases when we want to ignore some of the fields of a DTO. In these cases the user may add the \texttt{@DTOTransient} annotation to the field and it will be ignored by the binder.

\section{Binding a List of Business Objects}


\JDTO is capable of binding whole lists of business objects to DTOs. To do this, the binder has an utility method to bind a list of business objects: \texttt{bindFromBusinessObjectList}.

In the following sample code you can see how a list of business objects is converted into a List of DTOs. \JDTO has adopted the \texttt{List} collection as favorite type because it has the concept of insertion-oder, so if you had the business objects previously sorted, then the order remains. Also the framework needs a collection that has the possibility to access elements by index, so \texttt{List} was the right choice.


\begin{java}
LinkedList<SimpleEntity> simpleEntities = 
    new LinkedList<SimpleEntity>();
simpleEntities.add(new SimpleEntity("simple 1", 12, 45.56, true));
simpleEntities.add(new SimpleEntity("simple 2", 34, 56.67, false));

List<FormatDTO> dtos = binder.bindFromBusinessObjectList(FormatDTO.class, simpleEntities);
\end{java}


\section{Cascade Binding}


\JDTO by default copies values, it does not clone instances so is up to the value merger object to decide wether to clone, format, duplicate, or anything else. 
There are situations where you build a DTO (for example a Bill DTO) which is related to a single or a list of other DTOs. In this case the deep copy process will fail producing unexpected results. For this cases the framework provides an annotation type \texttt{DTOCascade} to instruct the binder it should build a DTO related instance.

The DTO Cascading feature supports different kinds of source fields:

\begin{itemize}
\item Single Value: A single association can be used as a source.
\item Collection: Any type of collection can be used as source.
\item Array: Any array can be used as a source. 
\end{itemize}


The target DTO type is inferred by convention or configuration. By convention the following rules apply:


\begin{itemize}
 \item If the target field is not a collection or array, then its type is used as the resulting DTO type.
 \item If the target field is a collection, then the generic type parameter is used as the resulting DTO type. If the generic type parameter is not present, the user will have to provide it as a configuration option.
 \item If the target field is an array, then the type of the components is used to create a DTO.
 \item For both collection and array targets, the source must be a collection or the ValueMerger must produce a collection.
\end{itemize}

The target DTO type can be configured as a parameter of the \texttt{DTOCascade} annotation type. The following example illustrates some usage of DTO Cascading.


\begin{java}
 public class ComplexArrayDTO {
    
    @DTOCascade
    @Source("sourceList")
    private FormatDTO[] formatDtos;
    ... // GETTERS AND SETTERS
}
\end{java}

\section{Compound Source Binding}

\JDTO supports composing the value of a target field out of multiple sources. For this purpose it provides the \texttt{@Sources} annotation type and the \texttt{MultiPropertyValueMerger} interface to merge the sources.
The user can safely rely on the parameters sent to the value merger are in the same order as defined on the \texttt{@Sources} annotation type.

The default value merger for the \texttt{@Sources} annotation type does not merge values, it just returns the first not-null element received or null if none.

\subsection{List of Built-in Multi Property Value Mergers}

\begin{itemize}
 \item \texttt{FirstObjectPropertyValueMerger}: This is the default merger, it returns the first non-null value.
 \item \texttt{StringFormatMerger} as described before, this merger uses the String.format method to merge all the provided values into a single formatted string.
\end{itemize}


The following example illustrates how Multi Property Value Mergers can be used for both, single and multiple source configurations:


\begin{java}
 public class FormatDTO {
    
    @Source(value="aDouble", merger=StringFormatMerger.class, 
        mergerParam="$ %.2f")
    private String price;
    
    @Sources(value={@Source("aDouble"), @Source("anInt")}, 
            merger=StringFormatMerger.class, mergerParam="%.2f %08d")
    private String compound;
    
    ... // GETTERS AND SETTERS
}
\end{java}


\section{Multiple Business Objects Sources}

\JDTO supports merging values for multiple source beans. In order to use this feature the framework provides the \texttt{@SourceNames} annotation type. The following example illustrates the basic usage of this feature:



\begin{java}
@SourceNames({"bean1", "bean2", "bean3"})
public class MultiSourceDTO {
    
    @Source(value="aString") // default bean1
    private String source1;
    @Source(value="aString", sourceBean="bean2")
    private String source2;
    @Source(value="aString", sourceBean="bean3")
    private String source3;
    
    ... // GETTERS AND SETTERS
}
\end{java}

The \texttt{@SourceNames} annotation can be used either on class level or in property level. When used at the class level acts as the default setting for all source fields. When used at the property level it overrides the settings for the class.

All of the methods on the binder instance are varargs and the parameters order must match the bean names order for the framework to read the source properties the right way.

Multi source properties also support multi bean sources and all the features it implies, the following example illustrates the power of multi source, multi bean DTO binding:


\begin{java}
@SourceNames({"bean1", "bean2"})
public class MultiSourceDTO2 {
    @Source("aString") //using bean1 as default
    private String string1;
    
    @Sources(value={@Source("anInt"), 
            @Source(value = "theDate", 
            sourceBean="bean2", 
            merger=DateFormatMerger.class, 
            mergerParam="dd/MM/yyyy")}, 
        merger=StringFormatMerger.class, mergerParam="%02d %s")
    private String string2;
    
    @Source(value = "theCalendar", sourceBean="bean2", 
        merger=DateFormatMerger.class, mergerParam="dd/MM/yyyy")
    private String string3;

    ... //GETTERS AND SETTERS
}
\end{java}

\section{Immutable DTOs}

\JDTO is capable of building instances of the DTOs using non default constructors, this brings you the possibility of creating immutable instances which
 are objects whose state doesn't change.
 
In order to use this feature, your class must not have a default constructor and may have more than one constructors. In order to choose which constructor you want the framework to use, you must annotate it with the \texttt{@DTOConstructor} annotation\footnote{Not required when there's just one constructor.} or define it into the XML settings.

The following is an example of a typical immutable DTO:

\begin{java}
public final class SimpleImmutableDTO {
    private final String firstString;
    private final String secondString;
    
    //make this the DTO constructor.
    @DTOConstructor
    public SimpleImmutableDTO(@Source("myString") String firstString, @Source("related.aString") String secondString) {
        this.firstString = firstString;
        this.secondString = secondString;
    }
    
    public SimpleImmutableDTO(String firstString, String secondString, String thirdString) {
        this.firstString = firstString;
        this.secondString = secondString;
    }
    
    public String getFirstString() {
        return firstString;
    }

    public String getSecondString() {
        return secondString;
    }    
}
\end{java}

Since there is no reliable way of getting the parameter names using the Java Reflection API (and therefore no safe way of creating a default configuration), the user must specify settings for each constructor argument. Failing to provide configuration for these arguments will cause a \texttt{RuntimeException} to be thrown.

You can't configure a constructor argument to be transient since the class is immutable there won't be a chance to change it later.

Some of these behaviors may change on the future.

\section{Reverse Binding: DTO To Business Object}

\JDTO is capable of reading DTO data and extract a business object of a given type by using the source fields (in the mapping) as target fields for the business object. Even though no extra configuration is required, this process is not as powerful as the original conversion. There are some hidden tricks here, for example, suppose your original business object had four integer fields that where added by some custom field merger. On the reverse process, how would the merger know how to unmerge these values?. 

By design, \JDTO sacrificed this capability of going back and forth 100\% for the flexibility of populating DTOs in a complex way. If you would like a more robust reverse conversion, you could add binding annotations to the business object and treat is as if it was a DTO helping the merge process by writing your own custom reverse-mergers.

The following snippet demonstrates how to apply reverse binding to extract a business object out of a DTO.


\begin{java}
//create a basic entity
SimpleEntity entity = new SimpleEntity("test", 123, 345.35, true);

//try and build a DTO out of the same entity.
SimpleEntity dto = 
    binder.bindFromBusinessObject(SimpleEntity.class, entity);

//change things on the dto
dto.setAnInt(10);
dto.setaBoolean(false);
dto.setaDouble(20.20);
dto.setaString("Changed!");

entity = binder.extractFromDto(SimpleEntity.class, dto);


assertEquals(10, entity.getAnInt());
assertEquals(false, entity.isaBoolean());
assertEquals(20.20, entity.getaDouble(), 0.0001);
assertEquals("Changed!", entity.getaString());
\end{java}


If the entity class argument is an implementation of \texttt{java.util.Map}, then the value returned will be a map, and the keys of the map will match the DTO mapping for the object passed as an argument. This means you can populate a map out of an object.


\section{XML Configuration}

\JDTO by default binds the DTOs using annotations but this is not the only option, there are some cases in which annotations are not convenient or even not available. For this cases, \JDTO provides a way to configure the DTO binding on a convenient XML file.

As this framework is built with the convention over configuration philosophy, you can start working with practically no configuration and customize just some things. By default, if there is a file on the default package called \DEFAULTCONFIG, then the framework will use it and disable the annotations config (which is actually the default when the file is not present). All the properties of a DTO are taken in account unless you explicitly declare them as transient. All DTOs declared on the XML file are loaded and analyzed eagerly, and non-configured DTOs are analyzed lazily the first time they're used.

Finally, the XML configuration file currently supports all the features the Annotation configuration support. There may be some additions on the future to make simpler the configuration.


Rather than explaining again the whole feature set, some examples will be shown and with the hope they're clear enough. Nevertheless a XML schema is available and most popular IDEs allow auto completion out of the schema.


\subsection{Basic XML Setup}

It is recommended to create an xml file on the default package called \DEFAULTCONFIG, and in its empty form should look like this:

\begin{xml}
<?xml version="1.0" encoding="UTF-8"?>
<dto-mapping 
    xmlns="http://jdto.org/jdto/1.0" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://jdto.org/jdto/1.0 
                        http://jdto.org/jdto-1.0.xsd">
        
</dto-mapping>
\end{xml}


\subsection{Simple XML Binding}

The following snippet demonstrates a DTO mapped in a really simple fashion:

\begin{xml}
<!-- to test simple binding -->
<dto type="org.jdto.dtos.XMLTesterDTO">

    <field name="aString" transient="true" />

    <!-- A field bound to another field. -->
    <field name="dtoName">
        <source name="aString" />
    </field>
</dto>
\end{xml}

\subsection{Navigating Associations}

The following snippet demonstrates a mapping which goes through property paths:

\begin{xml}
<!-- test the association feature -->
<dto type="org.jdto.dtos.SimpleAssociationDTO">
    <field name="firstString">
        <source name="myString" />
    </field>
    <field name="secondString">
        <source name="related.aString" />
    </field>
</dto>
\end{xml}

\subsection{Cascaded Mapping}

The following snippet demonstrates how the cascade logic can be mapped:

\begin{xml}
<!-- to test cascade logic -->
<dto type="org.jdto.dtos.ComplexDTO">
    <field name="cascadedField" cascade="true">
        <source name="association" />
    </field>
    <field name="stringField">
        <source name="name" />
    </field>
</dto>
\end{xml}


\subsection{Property Mergers}

The following snippet demonstrates how various property mergers can be configured:

\begin{xml}
<!-- test the compound merger feature -->
<dto type="org.jdto.dtos.FormatDTO">
    <!-- single field merger test -->
    <field  name="price">
        <source name="aDouble" 
        merger="org.jdto.mergers.StringFormatMerger"
        mergerParam="$ %.2f" />
    </field>
    <!-- multiple field merger test -->
    <field name="compound" mergerParam="%.2f %08d" 
    merger="org.jdto.mergers.StringFormatMerger">
        <source name="aDouble" />
        <source name="anInt" /> 
    </field>
</dto>
\end{xml}

In order to support multiple merger parameters without adding an excessive load of XML configuration, it's a design decision to separate those parameters in the same XML "mergerParam" attribute with semicolons ";", so for example if the value merger takes two parameters "first" and "second", the XML snippet would look like:

\texttt{mergerParam="first;second"}.

\subsection{Multiple Source Beans}

The following snippet demonstrates how you can configure mappings with multiple bean sources:

\begin{xml}
<!-- test the multi source feature -->
<dto type="org.jdto.dtos.MultiSourceDTO">
    <sourceNames>
        <beanName>bean1</beanName>
        <beanName>bean2</beanName>
        <beanName>bean3</beanName>
    </sourceNames>
    <field name="source1">
        <source name="aString" bean="bean1" />
    </field>
    <field name="source2">
        <source name="aString" bean="bean2" />
    </field>
    <field name="source3">
        <source name="aString" bean="bean3" />
    </field>
</dto> 
\end{xml}


\subsection{Immutable DTOs}

The following snippet demonstrates how you can configure a constructor to be used by the \JDTO framework:

\begin{xml}
<dto type="org.jdto.dtos.SimpleImmutableDTO">
    <immutableConstructor>
        <arg order="0" type="java.lang.String">
            <source name="test" bean="bean1" />
        </arg>
        <arg order="1" type="java.lang.Number">
            <source name="pepe" />
        </arg>
    </immutableConstructor>
</dto>
\end{xml}

The order attribute is optional, if not present, the declaration order will be taken into account. The "arg" XML element is very similar to the "field" element, but is different in the way that it doesn't have a name but defined by an order and a type and it can't be transient. 

All of the constructor arguments must be declared and also they must have at least one source property configured. This is mainly because there's no reliable way to read the argument names of one method in the java reflection API so it is impossible to assume a default configuration.


\section{Extending the Framework}

There are some ways to extend or customize the framework, the main way is to write custom property value mergers which will let you customize how the values are copied from the original object to the DTO. Another way of customizing the framework is by implementing a custom bean modifier (which will not be covered). 


\subsection{Implementing Custom Property Value Mergers}

\JDTO has two main types of property value mergers: Those who merge values from a single source and those who merge values from multiple sources. Both kinds of mergers are applied on the binding process but in different stages, for those fields annotated with \texttt{@Source} (or its XML equivalent), just the single property value merger is applied; for those fields annotated with \texttt{@Sources} (or its XML equivalent), one single property value merger is applied for each source, and then a multiple property value merger is applied to the results of the previous.

\subsection{Single Property Value Mergers}

In order to implement a single property value merger, you need to create a class that implements the interface \texttt{SinglePropertyValueMerger}.

The interface \texttt{SinglePropertyValueMerger} looks like the following, the generic type variables are added for developer convenience:

\begin{java}

/**
 * Merge a property into another type / form by applying a transformation. <br />
 * Transformations can be hinted by the extra param attribute.
 * @param R the type of the resulting property.
 * @param S the type of the source property, for developer convenience.
 * @author Juan Alberto Lopez Cavallotti
 */
public interface SinglePropertyValueMerger<R, S> {

    /**
     * Merge the value of type S into another object of type R.
     * @param values the value to be merged.
     * @param extraParam metadata that may help the merger to build the result.
     * @return the merged object.
     */
    public R mergeObjects(S value, String[] extraParam);
}

\end{java}

Each implementation of a property merger is kept as a singleton, therefore is not safe to use instance variables for user functionally.

\subsubsection{Utility Merger Templates}

The framework provides some utility template classes to implement property value mergers, some of these are:

\begin{itemize}
\item \texttt{AbstractCalulationCollectionMerger}: provides functionality to perform calculations on a given property of a collection or array.
\end{itemize}


\subsection{Multiple Property Value Mergers}

In order to implement a multiple property value merger, you need to create a class that implements the interface \texttt{MultiPropertyValueMerger}.

The interface \texttt{MultiPropertyValueMerger} looks like the following, the generic type variables are added for developer convenience:

\begin{java}
/**
 * Implementations should know how to merge a list of objects into a single object. <br />
 * This interface is meant to be used to create a single value out of a multi-source
 * property configuration, see {@link com.juancavallotti.jdto.annotation.Sources}.
 * @param <R> The result type of the merged parameters.
 * @author Juan Alberto Lopez Cavallotti
 */
public interface MultiPropertyValueMerger<R> {
    
    /**
     * Merge the list of objects into a single object.
     * @param values the values to be merged.
     * @param extraParam metadata that may help the merger to build the result.
     * @return the merge resulting object.
     */
    public R mergeObjects(List<Object> values, String[] extraParam);
}
\end{java}

Same considerations for single property value mergers should be taken.

\subsection{Accessing the Bean Modifier}

In some cases, the developer must read safely properties from the source objects (the same as the framework does to create the DTOs), for this purpose, you need to instruct the framework that you wish to work with a \texttt{BeanModifier} instance, to do this just implement the \texttt{BeanModifierAware} interface so the framework injects (by setter injection) the bean modifier to your property value merger before it calls the \texttt{mergeObjects} method, the interface looks like the following:

\begin{java}
/**
 * Makes this object aware of the current bean modifier used by the DTO binder
 * instance. Injection is performed by setter dependency injection.
 * @author Juan Alberto Lopez Cavallotti
 */
public interface BeanModifierAware {
    
    /**
     * Expose the BeanModifer to the implementing class.
     * @param modifier the bean modifier instance.
     */
    void setBeanModifier(BeanModifier modifier);
}
\end{java}

In this case it is safe to save the modifier instance in an instance variable of the property value merger.

\subsection{Math Expressions API}

\JDTO ships with a simple-to-use mathematic expression API you can take advantage, the variable resolution process can be either event-driven (lazy loaded) or the developer can provide a map matching each variable with its value. Please see javadoc for more information.


\end{document}